#!/usr/bin/env python3
"""
ROS2 Node Template - Generated by Claude Code ROS2 Code Validator

This template provides a foundation for creating ROS2 nodes with proper structure,
error handling, and best practices. Customize this template for your specific needs.

Template Features:
- Proper ROS2 node structure
- Parameter declaration and handling
- Publisher and subscriber setup
- Service server implementation
- Error handling and logging
- Lifecycle management
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy
from std_msgs.msg import String
from sensor_msgs.msg import LaserScan
from example_interfaces.srv import AddTwoInts
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup
import threading
from typing import Optional
import time


class Ros2NodeTemplate(Node):
    """
    ROS2 Node Template - Customize this class for your specific node functionality.

    This template includes:
    - Proper parameter handling
    - Publisher with QoS settings
    - Subscriber with error handling
    - Service server implementation
    - Resource cleanup
    - Logging best practices
    """

    def __init__(self):
        """Initialize the node with proper parameter declarations."""
        super().__init__('template_node_name')

        # Declare parameters with default values and descriptions
        self.declare_parameter('publish_frequency', 1.0)
        self.declare_parameter('laser_range_threshold', 1.0)
        self.declare_parameter('node_enabled', True)

        # Get parameter values
        self.publish_frequency = self.get_parameter('publish_frequency').value
        self.laser_threshold = self.get_parameter('laser_range_threshold').value
        self.node_enabled = self.get_parameter('node_enabled').value

        # Create callback groups for concurrent execution
        self.sub_callback_group = MutuallyExclusiveCallbackGroup()
        self.srv_callback_group = MutuallyExclusiveCallbackGroup()

        # Create QoS profiles for different use cases
        self.reliable_qos = QoSProfile(
            depth=10,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE
        )

        self.best_effort_qos = QoSProfile(
            depth=5,
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE
        )

        # Create publisher with proper QoS
        self.publisher = self.create_publisher(
            String,
            'template_topic_name',
            self.reliable_qos
        )

        # Create subscriber with proper QoS and error handling
        self.subscription = self.create_subscription(
            LaserScan,
            'scan',
            self.laser_callback,
            self.best_effort_qos,
            callback_group=self.sub_callback_group
        )

        # Create service server
        self.service = self.create_service(
            AddTwoInts,
            'add_two_ints',
            self.add_two_ints_callback,
            callback_group=self.srv_callback_group
        )

        # Create timer for periodic publishing
        self.timer = self.create_timer(
            1.0 / self.publish_frequency,
            self.timer_callback
        )

        # Initialize internal state
        self.message_counter = 0
        self.last_laser_ranges = []

        # Log successful initialization
        self.get_logger().info(
            f'Template Node initialized with frequency: {self.publish_frequency}Hz, '
            f'threshold: {self.laser_threshold}m, enabled: {self.node_enabled}'
        )

    def laser_callback(self, msg: LaserScan) -> None:
        """
        Handle incoming laser scan messages with proper error handling.

        Args:
            msg: LaserScan message containing range data
        """
        try:
            # Validate message content
            if not msg.ranges:
                self.get_logger().warn('Received empty laser scan ranges')
                return

            # Process the laser ranges safely
            self.last_laser_ranges = msg.ranges.copy()

            # Check for obstacles based on threshold
            min_range = min((r for r in self.last_laser_ranges if 0 < r < float('inf')), default=float('inf'))

            if min_range < self.laser_threshold:
                self.get_logger().warn(f'Obstacle detected at {min_range:.2f}m')
            else:
                self.get_logger().debug(f'No obstacles detected, min range: {min_range:.2f}m')

        except ValueError as e:
            self.get_logger().error(f'Error processing laser scan: {e}')
        except Exception as e:
            self.get_logger().error(f'Unexpected error in laser callback: {e}')

    def timer_callback(self) -> None:
        """
        Timer callback for periodic message publishing.

        Publishes status messages at the configured frequency.
        """
        try:
            if not self.node_enabled:
                return

            # Create and publish message
            msg = String()
            msg.data = f'Template Node message #{self.message_counter} at {time.time():.2f}'
            self.publisher.publish(msg)

            # Update counter
            self.message_counter += 1

            # Log every 10th message
            if self.message_counter % 10 == 0:
                self.get_logger().info(f'Published {self.message_counter} messages')

        except Exception as e:
            self.get_logger().error(f'Error in timer callback: {e}')

    def add_two_ints_callback(
        self,
        request: AddTwoInts.Request,
        response: AddTwoInts.Response
    ) -> AddTwoInts.Response:
        """
        Service callback to add two integers.

        Args:
            request: Request containing two integers to add
            response: Response to be filled with the sum

        Returns:
            Response with the calculated sum
        """
        try:
            # Validate inputs
            if not isinstance(request.a, int) or not isinstance(request.b, int):
                self.get_logger().error('Invalid input types for add_two_ints service')
                response.sum = 0
                return response

            # Perform calculation
            result = request.a + request.b
            response.sum = result

            # Log the operation
            self.get_logger().info(f'Calculated {request.a} + {request.b} = {result}')

            return response

        except Exception as e:
            self.get_logger().error(f'Error in add_two_ints service: {e}')
            response.sum = 0
            return response

    def update_parameters(self) -> None:
        """
        Example method to update parameters dynamically.

        This demonstrates proper parameter handling beyond initialization.
        """
        try:
            # Example of updating parameters during runtime
            new_freq = self.get_parameter('publish_frequency').value
            if new_freq != self.publish_frequency:
                # Cancel the old timer
                self.timer.cancel()

                # Update frequency
                self.publish_frequency = new_freq

                # Create new timer with updated frequency
                self.timer = self.create_timer(
                    1.0 / self.publish_frequency,
                    self.timer_callback
                )

                self.get_logger().info(f'Updated publish frequency to {self.publish_frequency}Hz')

        except Exception as e:
            self.get_logger().error(f'Error updating parameters: {e}')

    def get_internal_state(self) -> dict:
        """
        Get internal node state for monitoring purposes.

        Returns:
            Dictionary containing node state information
        """
        return {
            'message_counter': self.message_counter,
            'publish_frequency': self.publish_frequency,
            'laser_threshold': self.laser_threshold,
            'node_enabled': self.node_enabled,
            'last_laser_ranges_count': len(self.last_laser_ranges),
            'timestamp': time.time()
        }


def main(args=None):
    """
    Main function to initialize and run the ROS2 node.

    Args:
        args: Command line arguments (typically None)
    """
    try:
        # Initialize ROS2
        rclpy.init(args=args)

        # Create node instance
        template_node = Ros2NodeTemplate()

        # Create multi-threaded executor to handle callbacks concurrently
        executor = MultiThreadedExecutor(num_threads=4)
        executor.add_node(template_node)

        try:
            # Spin the node to process callbacks
            template_node.get_logger().info('Starting template node...')
            executor.spin()
        except KeyboardInterrupt:
            template_node.get_logger().info('Keyboard interrupt received')
        finally:
            # Cleanup
            executor.shutdown()
            template_node.destroy_node()

    except Exception as e:
        print(f'Error in main function: {e}')
    finally:
        # Always shutdown ROS2
        if rclpy.ok():
            rclpy.shutdown()


if __name__ == '__main__':
    main()